# QPID-demo
A demo of PID controller based on quantum computing

This demo is a PID controller. Compared to the classical PID controller, I used a Quantum Circuit to map the measurements  Kp, Ki, and Kd. 
In detail, this repository contains two implementations of a quantum-classical hybrid control system for BLDC motors:

## Main Branch (Full Implementation) (Update 2025/5/6)
- Complete quantum state reconstruction
- PID parameters mapped from θ and φ:
  - P = (cos(θ) + 1)/2
  - I = φ/(2π)
  - D = cos(θ)
- Theoretical rigor with proven results
- **(Update 2025/5/6)Reconstruct the transformation function of the controller for Position Control:**\
  $$G(s) = \frac{K_p s^2 + K_i s + K_d}{C_1 s^2 + C_2 s + C_3}$$
  - Used another three Quantum Circuits to get C1, C2, and C3
- (Update 2025/5/6) Apply this controller to UR10e Robot arm in mujoco
- (Update 2025/5/6) Use DeepSeek to give instructions to control the arm by inputting natural language
  - Support joint angle input
  - Support the coordinate of the end effector (Inverse Kinematics)
- (Update 2025/7/11) Add QAOA (Quantum Approximate Optimization Algorithm) algorithm for finetuning the result, which is generated by the LM algorithm
  - This is a Quantum-Classic hybrid method.
  - Using the Two-Stage Way (First stage: the LM algorithm, Second Stage: Using QAOA for finetuning) to make the IK error decrease from 0.x to 0.0x.
  - Fix some bugs in LM algorithm

## Simplified Branch
- Direct measurement mapping
- Simplified quantum circuits
- More resource-efficient
- Equally effective control performance

Both implementations demonstrate successful BLDC motor speed control with:
- Fast response time
- Minimal overshoot
- Stable steady-state performance

## (Update 2025/5/6)Requirement (This is my environment, probably you don't need the latest version)
- Python==3.12, Qiskit==1.4.0, mujoco==3.2.7, control=0.10.0

## (Update 2025/5/6)How to run
First
- Go to Deepseek's official website to get the API key: https://chat.deepseek.com/
Or alternatively,
- You can use other LLMs and modify the code.

Second
- Use the console to run:
```markdown
    python run_main.py
```
## Coming soon
- I will summarize a form to give the average position error under different instructions and compare that of my hybrid method with that of the LM algorithm 

This is the result of the response to the step signal.
![myplot2](https://github.com/user-attachments/assets/dfab5586-88d6-44ef-8797-9f3c818dba90)

## (Update 2025/7/11)Simulation 
- First Stage: LM algorithm
<img width="1500" height="800" alt="Figure_1" src="https://github.com/user-attachments/assets/873c55ac-f347-4548-b842-09c0337784cb" />

- Second Stage: Finetuning by QAOA
<img width="1500" height="800" alt="Figure_3" src="https://github.com/user-attachments/assets/1db4f88c-a172-4610-842c-1f97ee0531fb" />


## (Update 2025/7/11)This is the result of the response for end-effector control using my hybrid method.
<img width="1200" height="600" alt="Figure_4" src="https://github.com/user-attachments/assets/e7daee72-805c-4512-9b5e-99ec5cbf23d0" />

## (Update 2025/7/11) This is the position error from two stages:
- First Stage: LM algorithm
<img width="577" height="87" alt="截屏2025-07-11 00 16 24" src="https://github.com/user-attachments/assets/e0737766-f42d-4465-bbe5-a336983882a6" />

- Second Stage: Finetuning by QAOA
<img width="577" height="158" alt="截屏2025-07-11 00 17 51" src="https://github.com/user-attachments/assets/681a598e-9a89-4195-b580-4226bc0504c1" />

Thanks to Claude 3.7, because this demo is partially generated by it.
